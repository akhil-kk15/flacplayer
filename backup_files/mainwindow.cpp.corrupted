#include "mainwindow.h"
#include "ui_mainwindow.h"
#include <QDebug>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QPushButton>
#include <QLabel>
#include <QMessageBox>
#include <QWidget>
#include <QFileDialog>
#include <QStandardPaths>
#include <QSlider>
#include <QProgressBar>
#include <QFileInfo>
#include <QListWidgetItem>
#include <QInputDialog>

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
    , m_audioManager(nullptr)
    , m_duration(0)
    , m_seekSliderPressed(false)
{
    ui->setupUi(this);
    
    // Set button icons from resources
    ui->playPause->setIcon(QIcon(":/icons/assets/play.png"));
    ui->playPause->setIconSize(QSize(40, 40));
    ui->playPause->setText("");
    
    ui->nextTrack->setIcon(QIcon(":/icons/assets/next.png"));
    ui->nextTrack->setIconSize(QSize(40, 40));
    ui->nextTrack->setText("");
    
    ui->previousTrack->setIcon(QIcon(":/icons/assets/previous.png"));
    ui->previousTrack->setIconSize(QSize(40, 40));
    ui->previousTrack->setText("");
    
    ui->Shuffle->setIcon(QIcon(":/icons/assets/shuffle.png"));
    ui->Shuffle->setIconSize(QSize(40, 40));
    ui->Shuffle->setText("");
    
    ui->trackQueue->setIcon(QIcon(":/icons/assets/playlist.png"));
    ui->trackQueue->setIconSize(QSize(40, 40));
    ui->trackQueue->setText("");

    // Connect UI elements from the .ui file
    connect(ui->playPause, &QPushButton::clicked, this, &MainWindow::onPlayPause);
    connect(ui->nextTrack, &QPushButton::clicked, this, &MainWindow::onNext);
    connect(ui->previousTrack, &QPushButton::clicked, this, &MainWindow::onPrevious);
    connect(ui->Shuffle, &QPushButton::clicked, this, [this]() {
        m_playlist->setShuffle(!m_playlist->isShuffled());
    });
    connect(ui->seekSlider, &QSlider::sliderPressed, this, [this]() { m_seekSliderPressed = true; });
    connect(ui->seekSlider, &QSlider::sliderReleased, this, [this]() { 
        m_seekSliderPressed = false;
        onSeekPositionChanged(ui->seekSlider->value());
    });
    connect(ui->seekSlider, &QSlider::valueChanged, this, [this](int value) {
        if (m_seekSliderPressed) {
            ui->label->setText(formatTime(value));
        }
    });
    
    // Initialize audio manager
    m_audioManager = new AudioManager(this);
    connect(m_audioManager, &AudioManager::fileOpened, this, &MainWindow::onFileOpened);
    connect(m_audioManager, &AudioManager::fileClosed, this, &MainWindow::onFileClosed);
    connect(m_audioManager, &AudioManager::errorOccurred, this, &MainWindow::onAudioError);
    connect(m_audioManager, &AudioManager::stateChanged, this, &MainWindow::onAudioStateChanged);
    connect(m_audioManager, &AudioManager::positionChanged, this, &MainWindow::onAudioPositionChanged);
    connect(m_audioManager, &AudioManager::durationChanged, this, &MainWindow::onAudioDurationChanged);
    connect(m_audioManager, &AudioManager::albumArtChanged, this, &MainWindow::onAlbumArtChanged);
    connect(m_audioManager, &AudioManager::trackFinished, this, &MainWindow::onTrackFinished);
    connect(m_audioManager, &AudioManager::metadataChanged, this, &MainWindow::onMetadataChanged);
    
    // Initialize playlist
    m_playlist = new Playlist(this);
    connect(m_playlist, &Playlist::playlistChanged, this, &MainWindow::onPlaylistChanged);
    connect(m_playlist, &Playlist::currentIndexChanged, this, &MainWindow::onCurrentIndexChanged);
    connect(m_playlist, &Playlist::shuffleChanged, this, &MainWindow::onShuffleChanged);
    
    // Initialize the window
    initializeWindow();
    // setupBasicUI();  // Commented out - using UI file instead
    
    // Initialize UI elements that aren't in the .ui file
    setupAdditionalUI();
    
    // Set initial button states
    ui->playPause->setEnabled(false);



}

MainWindow::~MainWindow()
{
    delete ui;
}

void MainWindow::initializeWindow()
{
    // Set window properties
    setWindowTitle("FLAC Player v1.0");
    setMinimumSize(970, 650);
    resize(900, 650);
    
    // Status bar message
    statusBar()->showMessage("  Load audio files!", 3000);
}

void MainWindow::setupBasicUI()
{
    // REMOVED: Using UI file instead of programmatic creation
}

void MainWindow::setupAdditionalUI()
{
    // This function sets up UI elements that are NOT in the .ui file
    // These are elements that need to be created programmatically
    
    // Initialize pointers to avoid null references
    m_statusLabel = nullptr;
    m_timeLabel = nullptr;
    m_totalTimeLabel = nullptr;
    m_playlistNameLabel = nullptr;
}

void MainWindow::onShowAudioInfo()
{
    if (!m_audioManager->isFileOpen()) {
        QMessageBox::information(this, "No File", "Please open an audio file first!");
        return;
    }
    
    // Get metadata
    AudioMetadata metadata = m_audioManager->getMetadata();
    
    // Build detailed info string
    QString info = "═══════════════════════════════\n";
    info += "       AUDIO FILE DETAILS\n";
    info += "═══════════════════════════════\n\n";
    
    // Metadata section
    info += " METADATA:\n";
    info += "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n";
    info += QString("Title:    %1\n").arg(metadata.title.isEmpty() ? "N/A" : metadata.title);
    info += QString("Artist:   %1\n").arg(metadata.artist.isEmpty() ? "N/A" : metadata.artist);
    info += QString("Album:    %1\n").arg(metadata.album.isEmpty() ? "N/A" : metadata.album);
    info += QString("Year:     %1\n").arg(metadata.year.isEmpty() ? "N/A" : metadata.year);
    info += QString("Genre:    %1\n").arg(metadata.genre.isEmpty() ? "N/A" : metadata.genre);
    if (!metadata.comment.isEmpty()) {
        info += QString("Comment:  %1\n").arg(metadata.comment);
    }
    info += "\n";
    
    // Technical section
    info += " TECHNICAL INFO:\n";
    info += "─────────────────────────────\n";
    info += QString("Format:       %1\n").arg(m_audioManager->getFormatName());
    info += QString("Codec:        %1\n").arg(m_audioManager->getCodecName());
    info += QString("Sample Rate:  %1 Hz\n").arg(m_audioManager->getSampleRate());
    info += QString("Channels:     %1 (%2)\n")
        .arg(m_audioManager->getChannels())
        .arg(m_audioManager->getChannels() == 1 ? "Mono" : 
             m_audioManager->getChannels() == 2 ? "Stereo" :
             QString("%1 Channel").arg(m_audioManager->getChannels()));
    qint64 bitrate = m_audioManager->getBitrate();
    if (bitrate > 0) {
        info += QString("Bitrate:      %1 kbps\n").arg(bitrate / 1000);
    }
    info += QString("Duration:     %1 (%2 seconds)\n")
        .arg(formatTime(m_audioManager->getDuration()))
        .arg(m_audioManager->getDuration() / 1000000.0, 0, 'f', 2);
    info += "\n";
    
    // File section
    info += " FILE INFO:\n";
    info += "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n";
    QString currentFile = m_playlist->current();
    if (!currentFile.isEmpty()) {
        QFileInfo fileInfo(currentFile);
        info += QString("Filename:     %1\n").arg(fileInfo.fileName());
        info += QString("Path:         %1\n").arg(fileInfo.absolutePath());
        info += QString("Size:         %1 MB\n").arg(fileInfo.size() / 1024.0 / 1024.0, 0, 'f', 2);
    }
    
    // Show in a dialog with monospace font
    QMessageBox msgBox(this);
    msgBox.setWindowTitle("Audio File Information");
    msgBox.setText(info);
    msgBox.setIcon(QMessageBox::Information);
    
    // Use monospace font for better alignment
    QFont font("Monospace");
    font.setStyleHint(QFont::TypeWriter);
    font.setPointSize(9);
    msgBox.setFont(font);
    
    msgBox.exec();
}

// This shows debug information about your application
void MainWindow::onDebugInfo()
{
    QString info = QString(
        "=== QT APPLICATION DEBUG INFO ===\n\n"
        "Window Properties:\n"
        "  • Title: %1\n"
        "  • Size: %2 x %3 pixels\n"
        "  • Position: (%4, %5)\n"
        "  • Visible: %6\n\n"
        "Qt Information:\n"
        "  • Qt Version: %7\n"
        "  • Widget Count: %8\n\n"
        "  • Check the terminal for debug output!\n"
        "  • Try setting breakpoints\n"
        "  • Use qDebug() for logging"
    ).arg(windowTitle())
     .arg(width()).arg(height())
     .arg(x()).arg(y())
     .arg(isVisible() ? "Yes" : "No")
     .arg(QT_VERSION_STR)
     .arg(findChildren<QWidget*>().count());
    
    // Show in message box
    QMessageBox::information(this, "Debug Information", info);
    
    // Also print to console with detailed formatting
    qDebug().noquote() << "\n" << info;
}

// New FFmpeg-related slot functions

//file format changes needed 
void MainWindow::onOpenFile()
{
    QStringList fileNames = QFileDialog::getOpenFileNames(
        this,
        "Open Lossless Audio File(s)",
        QStandardPaths::writableLocation(QStandardPaths::MusicLocation),
        "Lossless Audio (*.flac *.wav *.ape *.wv *.m4a);;FLAC Files (*.flac);;WAV Files (*.wav);;All Files (*)"
    );
    
    if (!fileNames.isEmpty()) {
        // Add files to playlist
        m_playlist->addFiles(fileNames);
        
        // If this is the first file(s) added, start playing
        if (m_playlist->count() == fileNames.count()) {
            loadTrackAtIndex(0);
        }
    }
}

void MainWindow::onFileOpened(const QString &fileName)
{
    // Update window title with filename
    setWindowTitle("FLAC Player v1.0 - " + fileName);
    
    // Extract just the filename from full path
    QFileInfo fileInfo(fileName);
    ui->label->setText(fileInfo.fileName());
    
    if (m_statusLabel) m_statusLabel->setText("Status: File loaded - " + fileName);
    statusBar()->showMessage("Loaded: " + fileName, 5000);
    
    // Update audio info display
    if (m_audioManager->isFileOpen()) {
        if (m_audioInfoLabel) m_audioInfoLabel->setText(m_audioManager->getFormatInfo());
    }
    
    // Update playback controls
    updatePlaybackControls();
}

void MainWindow::onFileClosed()
{
    // Reset window title
    setWindowTitle("FLAC Player v1.0");
    
    ui->label->setText("No file loaded");
    
    if (m_statusLabel) m_statusLabel->setText("Status: No file loaded");
    if (m_audioInfoLabel) m_audioInfoLabel->setText("No audio file loaded");
    statusBar()->showMessage("File closed", 2000);
    
    // Reset playback controls
    m_duration = 0;
    if (m_timeLabel) m_timeLabel->setText("00:00 / 00:00");
    ui->seekSlider->setValue(0);
    updatePlaybackControls();
}

void MainWindow::onAudioError(const QString &error)
{
    QMessageBox::warning(this, "Audio Error", error);
    m_statusLabel->setText("Status: Error - " + error);
    statusBar()->showMessage("Error: " + error, 5000);
}

// Playback control slot functions
void MainWindow::onPlayPause()
{
    if (!m_audioManager->isFileOpen()) {
        QMessageBox::information(this, "No File", "Please open an audio file first!");
        return;
    }
    
    AudioManager::PlaybackState state = m_audioManager->getState();
    
    if (state == AudioManager::PlayingState) {
        m_audioManager->pause();
    } else {
        m_audioManager->play();
    }
    
    updatePlaybackControls();
}

void MainWindow::onStop()
{
    m_audioManager->stop();
}

void MainWindow::onPrevious()
{
    if (!m_playlist || m_playlist->count() == 0) {
        return;
    }
    if (m_playlist->hasPrevious()) {
        QString prevFile = m_playlist->previous();
        if (!prevFile.isEmpty()) {
            m_audioManager->stop();
            m_audioManager->openFile(prevFile);
            m_audioManager->play();
        }
    }
}

void MainWindow::onNext()
{
    if (!m_playlist || m_playlist->count() == 0) {
        return;
    }
    if (m_playlist->hasNext()) {
        QString nextFile = m_playlist->next();
        if (!nextFile.isEmpty()) {
            m_audioManager->stop();
            m_audioManager->openFile(nextFile);
            m_audioManager->play();
        }
    }
}

void MainWindow::onTrackFinished()
{
    // Auto-advance to next track if available
    if (m_playlist && m_playlist->hasNext()) {
        onNext();
    } else {
        m_audioManager->stop();
    }
}

void MainWindow::onVolumeChanged(int value)
{
    qreal volume = value / 100.0; // Convert to 0.0-1.0 range
    m_audioManager->setVolume(volume);
}

void MainWindow::onSeekPositionChanged(int value)
{
    if (m_duration > 0) {
        qint64 position = (qint64(value) * m_duration) / 1000;
        m_audioManager->setPosition(position);
    }
}

void MainWindow::onAudioStateChanged(AudioManager::PlaybackState state)
{
    updatePlaybackControls();
    
    QString stateText;
    switch (state) {
    case AudioManager::StoppedState:
        stateText = "Stopped";
        break;
    case AudioManager::PlayingState:
        stateText = "Playing";
        break;
    case AudioManager::PausedState:
        stateText = "Paused";
        break;
    }
    
    statusBar()->showMessage("Playback: " + stateText, 2000);
}

void MainWindow::onAudioPositionChanged(qint64 position)
{
    // Update elapsed time display
    if (m_timeLabel) {
        m_timeLabel->setText(formatTime(position));
    }

    // Update seek slider (only if user is not dragging it)
    if (!m_seekSliderPressed && m_duration > 0) {
        int sliderValue = (int)((position * 1000) / m_duration);
        ui->seekSlider->setValue(sliderValue);
    }
}

void MainWindow::onAudioDurationChanged(qint64 duration)
{
    m_duration = duration;
    
    // Update elapsed / total time labels
    if (m_timeLabel) {
        m_timeLabel->setText(formatTime(0));
    }
    if (m_totalTimeLabel) {
        m_totalTimeLabel->setText(formatTime(duration));
    }

    // Reset seek slider
    ui->seekSlider->setValue(0);
}

void MainWindow::onAlbumArtChanged(const QPixmap &albumArt)
{
    // Album art display not implemented in current UI
    Q_UNUSED(albumArt);
}

void MainWindow::onMetadataChanged(const AudioMetadata &metadata)
{
    if (!metadata.isEmpty()) {
        // Display title
        if (m_titleLabel) {
            if (!metadata.title.isEmpty()) {
                m_titleLabel->setText(metadata.title);
            } else {
                m_titleLabel->setText("Unknown Title");
            }
        }
        
        // Display artist
    // Update filename label with track info if available
    if (!metadata.title.isEmpty()) {
        QString displayText = metadata.title;
        if (!metadata.artist.isEmpty()) {
            displayText += " - " + metadata.artist;
        }
        ui->label->setText(displayText
    // Current track changed - update button states
    Q_UNUSED(index);
    updatePlaybackControls();
}

void MainWindow::onPlaylistItemDoubleClicked(QListWidgetItem *item)
{
    // Playlist widget not implemented in UI
    Q_UNUSED(item);
}

void MainWindow::onShuffleToggled(bool checked)
{
    m_playlist->setShuffle(checked);
}

void MainWindow::onShuffleChanged(bool enabled)
{
    // Update button state
    m_shuffleButton->setChecked(enabled);
    
    // Update shuffle button style
    if (enabled) {
        ui->Shuffle->setStyleSheet(ui->Shuffle->styleSheet() + " background-color: #4CAF50;");
        if (m_statusLabel) m_statusLabel->setText("Shuffle: ON");
    } else {
        // Reset to original style from UI file
        ui->Shuffle->setStyleSheet("");
        if (m_statusLabel) m_statusLabel->setText("Shuffle: OFF"
void MainWindow::onSavePlaylist()
{
    if (!m_playlist || m_playlist->count() == 0) {
        QMessageBox::information(this, "Empty Playlist", "Cannot save an empty playlist.");
        return;
    }
    
    QString defaultPath = QStandardPaths::writableLocation(QStandardPaths::MusicLocation);
    QString fileName = QFileDialog::getSaveFileName(
        this,
        "Save Playlist",
        defaultPath + "/" + m_playlist->getName() + ".m3u",
        "M3U Playlist (*.m3u);;All Files (*)"
    );
    
    if (!fileName.isEmpty()) {
        if (m_playlist->saveToFile(fileName)) {
            statusBar()->showMessage("Playlist saved: " + fileName, 3000);
            QMessageBox::information(this, "Success", "Playlist saved successfully!");
        } else {
            QMessageBox::warning(this, "Error", "Failed to save playlist.");
        }
    }
}

void MainWindow::onLoadPlaylist()
{
    QString defaultPath = QStandardPaths::writableLocation(QStandardPaths::MusicLocation);
    QString fileName = QFileDialog::getOpenFileName(
        this,
        "Load Playlist",
        defaultPath,
        "M3U Playlist (*.m3u);;All Files (*)"
    );
    
    if (!fileName.isEmpty()) {
        if (m_playlist->loadFromFile(fileName)) {
            m_playlistNameLabel->setText(m_playlist->getName());
            statusBar()->showMessage("Playlist loaded: " + m_playlist->getName(), 3000);
            
            // Auto-start playing the first track if available
            if (m_playlist->count() > 0) {
                loadTrackAtIndex(0);
            }
        } else {
            QMessageBox::warning(this, "Error", "Failed to load playlist.");
        }
    }
}

void MainWindow::onNewPlaylist()
{
    if (m_playlist->count() > 0) {
        auto reply = QMessageBox::question(
            this,
            "New Playlist",
            "Current playlist will be cleared. Continue?",
            QMessageBox::Yes | QMessageBox::No
        );
        
        if (reply == QMessageBox::No) {
            return;
        }
    }
    
    bool ok;
    QString name = QInputDialog::getText(
        this,
        "New Playlist",
        "Enter playlist name:",
        QLineEdit::Normal,
        "My Playlist",
        &ok
    );
    
    if (ok && !name.isEmpty()) {
        m_audioManager->stop();
        m_playlist->clear();
        m_playlist->setName(name);
        m_playlistNameLabel->setText(name);
        statusBar()->showMessage("New playlist created: " + name, 2000);
    }
}

void MainWindow::onClearPlaylist()
{
    if (!m_playlist || m_playlist->count() == 0) {
        return;
    }
    
    auto reply = QMessageBox::question(
        this,
        "Clear Playlist",
        "Are you sure you want to clear the playlist?",
        QMessageBox::Yes | QMessageBox::No
    );
    
    if (reply == QMessageBox::Yes) {
        m_audioManager->stop();
        m_playlist->clear();
        statusBar()->showMessage("Playlist cleared", 2000);
    }
}

void MainWindow::onEditMetadata()
{
    QString currentFile = m_playlist->current();
    if (currentFile.isEmpty()) {
        QMessageBox::information(this, "No File", "Please load a file first.");
        return;
    }
    
    MetadataEditor editor(currentFile, this);
    if (editor.exec() == QDialog::Accepted) {
        // Reload the file to refresh metadata
        statusBar()->showMessage("Metadata updated. Reloading file...", 3000);
        
        // Reload current file
        bool wasPlaying = (m_audioManager->getState() == AudioManager::PlayingState);
        qint64 currentPos = m_audioManager->getPosition();
        
        m_audioManager->stop();
        if (m_audioManager->openFile(currentFile)) {
            if (wasPlaying) {
                m_audioManager->setPosition(currentPos);
                m_audioManager->play();
            }
        }
    }
}

void MainWindow::onConvertToMP3()
{
    QString currentFile = m_playlist->current();
    if (currentFile.isEmpty()) {
        QMessageBox::information(this, "No File", "Please load a file first.");
        return;
    }
    
    // Check if file is already MP3
    if (currentFile.toLower().endsWith(".mp3")) {
        QMessageBox::information(this, "Already MP3", "The current file is already in MP3 format.");
        return;
    }
    
    ConversionDialog dialog(currentFile, this);
    dialog.exec();
}

void MainWindow::onConvertSelectedSong()
{
    QListWidgetItem *item = m_playlistWidget->currentItem();
    if (!item) {
        QMessageBox::information(this, "No Selection", "Please select a song from the playlist.");
        return;
    }
    
    int index = m_playlistWidget->row(item);
    QString filePath = m_playlist->getFileAt(index);
    
    if (filePath.isEmpty()) {
        QMessageBox::warning(this, "Error", "Could not retrieve file path.");
        return;
    }
    
    // Check if file is already MP3
    if (filePath.toLower().endsWith(".mp3")) {
        QMessageBox::information(this, "Already MP3", "The selected file is already in MP3 format.");
        return;
    }
    
    ConversionDialog dialog(filePath, this);
    dialog.exec();
}

void MainWindow::onConvertAllPlaylist()
{
    QStringList nonMP3Files = getNonMP3FilesFromPlaylist();
    
    if (nonMP3Files.isEmpty()) {
        QMessageBox::information(this, "Nothing to Convert", "All files in the playlist are already in MP3 format.");
        return;
    }
    
    auto reply = QMessageBox::question(this, "Convert All",
                                  QString("Convert %1 file(s) to MP3?\nThis may take some time.")
                                      .arg(nonMP3Files.count()),
                                  QMessageBox::Yes | QMessageBox::No);
    
    if (reply == QMessageBox::Yes) {
        convertFilesToMP3(nonMP3Files);
    }
}

void MainWindow::showPlaylistContextMenu(const QPoint &pos)
{
    QListWidgetItem *item = m_playlistWidget->itemAt(pos);
    
    QMenu contextMenu(this);
    
    if (item) {
        // Single item selected
        int index = m_playlistWidget->row(item);
        QString filePath = m_playlist->getFileAt(index);
        bool isMP3 = filePath.toLower().endsWith(".mp3");
        
        QAction *playAction = contextMenu.addAction("Play");
        connect(playAction, &QAction::triggered, [this, item]() {
            onPlaylistItemDoubleClicked(item);
        });
        
        contextMenu.addSeparator();
        
        QAction *convertAction = contextMenu.addAction("Convert to MP3");
        convertAction->setEnabled(!isMP3);
        connect(convertAction, &QAction::triggered, this, &MainWindow::onConvertSelectedSong);
    }
    
    // Always show convert all option
    if (m_playlist && m_playlist->count() > 0) {
        if (item) {
            contextMenu.addSeparator();
        }
        
        QStringList nonMP3Files = getNonMP3FilesFromPlaylist();
        QAction *convertAllAction = contextMenu.addAction(QString("Convert All to MP3 (%1 files)")
                                                              .arg(nonMP3Files.count()));
        convertAllAction->setEnabled(!nonMP3Files.isEmpty());
        connect(convertAllAction, &QAction::triggered, this, &MainWindow::onConvertAllPlaylist);
    }
    
    if (!contextMenu.isEmpty()) {
        contextMenu.exec(m_playlistWidget->mapToGlobal(pos));
    }
}

void MainWindow::convertFilesToMP3(const QStringList &files)
{
    if (files.isEmpty()) {
        return;
    }
    
    // For now, convert files one by one
    // TODO: Implement a batch conversion dialog with progress tracking
    int successCount = 0;
    int failureCount = 0;
    QStringList failedFiles;
    
    for (const QString &file : files) {
        ConversionDialog dialog(file, this);
        if (dialog.exec() == QDialog::Accepted) {
            successCount++;
        } else {
            failureCount++;
            QFileInfo info(file);
            failedFiles.append(info.fileName());
        }
    }
    
    // Show summary
    QString message = QString("Conversion complete:\n%1 successful, %2 failed")
                          .arg(successCount).arg(failureCount);
    
    if (!failedFiles.isEmpty()) {
        message += "\n\nFailed files:\n" + failedFiles.join("\n");
    }
    
    QMessageBox::information(this, "Batch Conversion Complete", message);
}

QStringList MainWindow::getNonMP3FilesFromPlaylist() const
{
    QStringList nonMP3Files;
    const QStringList allFiles = m_playlist->getFiles();
    
    for (const QString &file : std::as_const(allFiles)) {
        if (!file.toLower().endsWith(".mp3")) {
            nonMP3Files.append(file);
        }
    }
    
    return nonMP3Files;
}

// Helper functions
void MainWindow::loadTrackAtIndex(int index)
{
    if (index < 0 || index >= m_playlist->count()) {
        return;
    }
    
    QString filePath = m_playlist->getFileAt(index);
    if (filePath.isEmpty()) {
        return;
    }
    
    m_playlist->setCurrentIndex(index);
    m_audioManager->stop();
    
    if (m_audioManager->openFile(filePath)) {
        m_audioManager->play();
    }
}

void MainWindow::updatePlaybackControls()
{
    AudioManager::PlaybackState state = m_audioManager->getState();
    bool hasFile = m_audioManager->isFileOpen();
    
    // Update play/pause button
    if (state == AudioManager::PlayingState) {
        ui->playPause->setIcon(QIcon(":/icons/assets/pause.png"));
    } else {
        ui->playPause->setIcon(QIcon(":/icons/assets/play.png"));
    }
    
    // Enable/disable controls based on file availability
    ui->playPause->setEnabled(hasFile);
    ui->seekSlider->setEnabled(hasFile);
    ui->nextTrack->setEnabled(hasFile && m_playlist && m_playlist->count() > 1);
    ui->previousTrack->setEnabled(hasFile && m_playlist && m_playlist->count() > 1);
}

QString MainWindow::formatTime(qint64 microseconds) const
{
    qint64 seconds = microseconds / 1000000;
    qint64 minutes = seconds / 60;
    seconds = seconds % 60;
    
    return QString("%1:%2")
        .arg(minutes, 2, 10, QChar('0'))
        .arg(seconds, 2, 10, QChar('0'));
}
